<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Type Erasure CppCon 2014</title>

    <meta name="author", content="T. Zachary Laine">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <link rel="stylesheet" href="lib/css/zenburn.css">

    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown=""
               data-separator="^====+$"
               data-vertical="^----+$"
               data-notes="^Note:">
        <script type="text/template">

# Type Erasure
## Solving Classic OOP Problems with an Elegant Design Pattern
### Zach Laine, CppCon 2014

====================

## Outline
- The Importance of Values
- The Polymorphism Problem
- Those Other Solutions
- Using Type Erasure

====================

# Part 1
## The Importance of Values

----

### Dealing with values instead of references has a couple of very nice benefits

- Clear ownership/lifetime semantics
- Equational reasoning

----

## Clear Semantics

Who owns `foo`?

```cpp
foo_t * foo_factory ();
...
foo_t * foo = foo_factory();
```

Is this better?
<!-- .element: class="fragment" data-fragment-index="1" -->

```cpp
std::shared_ptr<foo_t> foo_factory ();
...
std::shared_ptr<foo_t> foo = foo_factory();
```
<!-- .element: class="fragment" data-fragment-index="1" -->

That depends on whether you're partial to global state....
<!-- .element: class="fragment" data-fragment-index="2" -->

----

## Equational Reasoning

```cpp
foo_t * foo_factory ();
void foo_user (foo_t * f);
...
foo_t * foo = foo_factory();
foo_user(foo);

// What can I say about foo here?
```

With value types, you only have to reason about the values in the code front
of you.

With reference types, you must **simultaneously** reason about code that
mutates the values elsewhere.

====================

# Part 2
## The Polymorphism Problem

----

## Why Polymorphism?
### Code reuse of course!

Q: How does the author of this function intend its users to use it?

```cpp
bool my_predicate (some_t obj);
```

A: Non-polymorphically.  You have to give me a <!-- .element: class="fragment" data-fragment-index="1" -->`some_t` object, or get sliced.
Not terribly reusable with other types.
<!-- .element: class="fragment" data-fragment-index="1" -->

----

Q: How about this one?

```cpp
bool my_predicate (const base_t & obj);
```

A: Runtime-polymorphically.  You can give me any <!-- .element: class="fragment" data-fragment-index="1" -->
`base_t`-derived object by
reference.  The function is now more reusable, but you must use inheritance.
Yuck!<!-- .element: class="fragment" data-fragment-index="1" -->


----

Q: Or this?

```cpp
template <typename T>
bool my_predicate (T obj);
```

A: Compile-time-polymorphically.  You can give me any object whose type can be
used to instantiated the template.  The function is now even more reusable,
but you must use metaprogramming. Gross!
<!-- .element: class="fragment" data-fragment-index="1" -->

====================

## Runtime Polymorphism Problems

----

The inheritance mechanism gives us polymorphism, but we must either:

- Limit ourselves to a single interface found in the base class:

```cpp
struct base
{ virtual int foo () const = 0; };

struct derived : base
{
    virtual int foo () const
    { return 42; }

    static const int pi = 3;

    bar double bar () const
    { return 1.0 * pi; }
};

base * b_pointer = new derived;
function_requiring_foo_member(b_pointer); // Yay!
function_requiring_bar_member(b_pointer); // Aww...
```

*OR*

----

- Use multiple inheritance to bolt on multiple interfaces:

```cpp
struct base { virtual int foo () { return 42; } };
struct derived_1 : public base {};
struct derived_2 : public base {};
struct derived_subclass : public derived_1, public derived_2 {};
```

Which leads to the "diamond of death",
<!-- .element: class="fragment" data-fragment-index="1" -->

which leads to virtual inheritance,
<!-- .element: class="fragment" data-fragment-index="2" -->

which leads to fear,
<!-- .element: class="fragment" data-fragment-index="3" -->

which leads to anger,
<!-- .element: class="fragment" data-fragment-index="4"-->

... you get it.
<!-- .element: class="fragment" data-fragment-index="5" -->

----

We cannot make classes from different class hierarchies conform to a common
interface, because they have no common base to use when passing them.

```cpp
struct int_base
{
    virtual int foo () { return 42; }
    virtual void log () const;
};
struct float_base
{
    virtual float foo () { return 3.0; }
    virtual void log () const;
};

struct int_derived : public int_base {};
struct float_derived : public float_base {};
```

Note that `int_derived` and `float_derived` both have a `void log () const`.

----

So, we ditch code reuse in the case of logging:

```cpp
void log_to_terminal (const int_base & loggee);
void log_to_terminal (const double_base & loggee);
```

Or we resort to ugly hacks:

```cpp
struct log_base { virtual void log () const; };
struct int_base : log_base {/*...*/}; 
struct float_base : log_base {/*...*/}; 
void log_to_terminal (const log_base & loggee);
```

----

We cannot easily separate interface and implementation without using multiple
inheritance.

----

Virtual functions can be tricky to get right, especially in large class
heirarchies.

- We've all seen lots of these problems in real code.
- C++11's `override` and `final` help
- There is frequently a question of whether or not a given type's virtual
  function implementation should call its base class's version of the same
  function.

----

In addition to all the above limitations, we are limited in which interfaces
we give to which types by our choice of base class(es).

- Inheritance imposes very tight coupling.
- It is not possible to have unrelated types with the same interfaces used
  interchangably.

----

We must always take parameters by reference to use runtime polymorphism.
There go our nice benefits from value semantics.

====================

## Compile-time Polymorphism Problems

TODO

====================

## There **must** be a better way!

![](there_must_be_a_better_way.gif)

        </script>
      </section>
    </div>
  </div>


  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.min.js"></script>
  <script>
    Reveal.initialize({
        slideNumber: true,

        dependencies: [
            { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
            { src: 'plugin/math/math.js', async: true },
            { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
    });
  </script>
</body>

</html>
